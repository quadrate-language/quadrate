// Copyright 2025 Joachim Klahr
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

__c {
	#include <stdio.h>
	#include <stdlib.h>
	#include <stdarg.h>
}

fn exit() {
	__c {
		if (__qd_stack_ptr == 0) {
			exit(0);
		}
		exit(__qd_stack[__qd_stack_ptr-1]);
	}	
}

fn fopen() {
	__c {
		va_list args;
		va_start(args, n);
		const char* filename = (const char*)va_arg(args, const char*);
		va_end(args);

		FILE* f = fopen(filename, "rb");
		if (!f) {
			__qd_panic_invalid_input();
			return;
		}
		__qd_arg_push(__qd_ptr_to_real(f));
	}
}

fn fclose() {
	__c {
		if (__qd_stack_ptr < 1) {
			__qd_panic_stack_underflow();
			return;
		}
		FILE* f = (FILE*)__qd_real_to_ptr(__qd_stack[--__qd_stack_ptr]);
		if (fclose(f) != 0) {
			__qd_panic_invalid_input();
			return;
		}
	}
}

fn fsize() {
	__c {
		if (__qd_stack_ptr < 1) {
			__qd_panic_stack_underflow();
			return;
		}
		FILE* f = (FILE*)__qd_real_to_ptr(__qd_stack[--__qd_stack_ptr]);
		if (fseek(f, 0, SEEK_END) != 0) {
			__qd_panic_invalid_input();
			return;
		}
		long size = ftell(f);
		if (size < 0) {
			__qd_panic_invalid_input();
			return;
		}
		rewind(f);
		__qd_arg_push((__qd_real_t)size);
	}
}

fn ftell() {
	__c  {
		if (__qd_stack_ptr < 1) {
			__qd_panic_stack_underflow();
			return;
		}
		FILE* f = (FILE*)__qd_real_to_ptr(__qd_stack[--__qd_stack_ptr]);
		long pos = ftell(f);
		if (pos < 0) {
			__qd_panic_invalid_input();
			return;
		}
		__qd_arg_push((__qd_real_t)pos);
	}
}

fn fread() {
	__c {
		if (__qd_stack_ptr < 1) {
			__qd_panic_stack_underflow();
			return;
		}
		FILE* f = (FILE*)__qd_real_to_ptr(__qd_stack[--__qd_stack_ptr]);
		unsigned char c;
		size_t read = fread(&c, 1, 1, f);
		__qd_arg_push((__qd_real_t)c);
	}
}

fn readfile() {
	__c {
		va_list args;
		va_start(args, n);
		const char* filename = (const char*)va_arg(args, const char*);
		va_end(args);

		FILE* f = fopen(filename, "r");
		if (!f) {
			__qd_panic_invalid_input();
			return;
		}

		if (fseek(f, 0, SEEK_END) != 0) {
			fclose(f);
			__qd_panic_invalid_input();
			return;
		}

		long size = ftell(f);
		if (size < 0) {
			fclose(f);
			__qd_panic_invalid_input();
			return;
		}

		rewind(f);

		char* buffer = malloc(size + 1);
		if (!buffer) {
			fclose(f);
			__qd_panic_out_of_memory();
			return;
		}

		size_t read = fread(buffer, 1, size, f);
		if (read != size) {
			fclose(f);
			free(buffer);
			__qd_panic_invalid_data();
			return;
		}

		buffer[size] = '\0';
		fclose(f);

		__qd_eval(0, buffer);
		free(buffer);
	}
}

fn writefile() {
	__c {
		va_list args;
		va_start(args, n);
		const char* filename = (const char*)va_arg(args, const char*);
		va_end(args);

		FILE* f = fopen(filename, "w");
		if (!f) {
			__qd_panic_invalid_input();
			return;
		}

		for (int i = 0; i < __qd_stack_ptr; i++) {
			if (fprintf(f, "%.*f\n", __qd_precision, __qd_stack[i]) < 0) {
				fclose(f);
				__qd_panic_out_of_memory();
				return;
			}
		}

		if (ferror(f)) {
			fclose(f);
			__qd_panic_out_of_memory();
			return;
		}

		fclose(f);
	}
}

