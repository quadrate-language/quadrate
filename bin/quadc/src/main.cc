#include "compiler.h"
#include "cxxopts.hpp"
#include <cgen/writer.h>
#include <filesystem>
#include <fstream>
#include <iostream>

#define QUADC_VERSION "0.1.0"

int main(int argc, char** argv) {
	cxxopts::Options options("quadc", "Quadrate compiler");
	options.add_options()("h,help", "Display help.")("v,version", "Display compiler version.")(
			"o", "Output filename", cxxopts::value<std::string>()->default_value("main"))(
			"save-temps", "Save temporary files", cxxopts::value<bool>()->default_value("false"))(
			"no-colors", "Disable colored output", cxxopts::value<bool>()->default_value("false"))(
			"dump-tokens", "Print tokens", cxxopts::value<bool>()->default_value("false"))(
			"r,run", "Run the compiled program", cxxopts::value<bool>()->default_value("false"))(
			"files", "Input files", cxxopts::value<std::vector<std::string>>());

	options.parse_positional({"files"});
	auto result = options.parse(argc, argv);

	if (result.count("help") || argc == 1) {
		std::cout << options.help() << std::endl;
		return 0;
	}

	if (result.count("version")) {
		std::cout << QUADC_VERSION << std::endl;
		return 0;
	}

	std::string outputFilename = result["o"].as<std::string>();

	std::string outputDir = ".out";
	Compiler compiler(outputDir.c_str());
	const char* mainFile = "// This file is automatically generated by the Quadrate compiler.\n"
						   "// Do not edit manually.\n\n"
						   "#include <quadrate/runtime/runtime.h>\n\n"
						   "extern qd_exec_result main_main(qd_context* ctx);\n\n"
						   "int main(void) {\n"
						   "    qd_context ctx;\n"
						   "    qd_stack_init(&ctx.st, 1024);\n"
						   "    main_main(&ctx);\n"
						   "    qd_stack_destroy(ctx.st);\n"
						   "    return 0;\n"
						   "}\n";
	std::ofstream mainFileStream(outputDir + "/main.c");
	mainFileStream << mainFile;
	mainFileStream.close();

	auto args = result.arguments();
	if (args.size() > 0) {
		std::vector<TranslationUnit> translationUnits;
		if (auto tu = compiler.compile((outputDir + "/main.c").c_str(), "-I./dist/include")) {
			translationUnits.push_back(*tu);
		} else {
			std::cerr << "quadc: compilation failed for main.c" << std::endl;
			return 1;
		}
		for (const auto& arg : args) {
			std::ifstream file(arg.value());
			if (!file.is_open()) {
				std::cerr << "quadc: cannot find " << arg.value() << ": No such file or directory" << std::endl;
				continue;
			}
			file.seekg(0, std::ios::end);
			auto pos = file.tellg();
			file.seekg(0);
			if (pos < 0) {
				std::cerr << "quadc: error reading " << arg.value() << std::endl;
				continue;
			}
			size_t size = static_cast<size_t>(pos);
			std::string buffer(size, ' ');
			file.read(&buffer[0], static_cast<std::streamsize>(size));
			std::string filename = std::filesystem::path(arg.value()).filename().string();

			if (compiler.transpile(filename.c_str(), "main", buffer.c_str())) {
				std::cout << "quadc: transpiled " << arg.value() << " successfully." << std::endl;
			} else {
				std::cerr << "quadc: transpilation failed for " << arg.value() << std::endl;
				return 1;
			}

			if (auto tu = compiler.compile((".out/main/" + filename + ".c").c_str(), "-I./dist/include")) {
				translationUnits.push_back(*tu);
			} else {
				std::cerr << "quadc: compilation failed for " << arg.value() << std::endl;
				return 1;
			}
		}

		bool linkSuccess = compiler.link(translationUnits, outputFilename.c_str(),
				"-I./dist/include -L./dist/lib -lquadrate_static -lm -pthread");
		if (!linkSuccess) {
			std::cerr << "quadc: linking failed" << std::endl;
			return 1;
		}
	}

	return 0;
}
