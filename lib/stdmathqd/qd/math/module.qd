// Mathematical constants
const Pi = 3.141592653589793
const E = 2.718281828459045
const Tau = 6.283185307179586

// Import native math functions from libstdmathqd
import "libstdmathqd_static.a" as "math" {
	// Trigonometric functions
	fn sin(x:f64 -- result:f64)
	fn cos(x:f64 -- result:f64)
	fn tan(x:f64 -- result:f64)
	fn asin(x:f64 -- result:f64)
	fn acos(x:f64 -- result:f64)
	fn atan(x:f64 -- result:f64)

	// Power and root functions
	fn sqrt(x:f64 -- result:f64)
	fn cbrt(x:f64 -- result:f64)
	fn pow(base:f64 exp:f64 -- result:f64)

	// Logarithmic functions
	fn ln(x:f64 -- result:f64)
	fn log10(x:f64 -- result:f64)

	// Rounding functions
	fn ceil(x:f64 -- result:f64)
	fn floor(x:f64 -- result:f64)
	fn round(x:f64 -- result:f64)
}

// Pure Quadrate implementations (simpler than C equivalents)

pub fn inc( x:i64 -- result:i64 ) {
	// Increment integer by 1
	1 add
}

pub fn dec( x:i64 -- result:i64 ) {
	// Decrement integer by 1
	1 sub
}

pub fn sq( x:f64 -- result:f64 ) {
	// Square: x * x
	dup mul
}

pub fn cb( x:f64 -- result:f64 ) {
	// Cube: x * x * x
	dup dup mul mul
}

pub fn abs( x:f64 -- result:f64 ) {
	// Absolute value: |x|
	dup 0.0 lt if {
		neg
	}
}

pub fn inv( x:f64 -- result:f64 ) {
	// Reciprocal: 1/x
	1.0 swap div
}

pub fn fac( n:i64 -- result:i64 ) {
	// Factorial: n!
	-> n
	1 -> result
	1 n 1 add 1 for {
		result $ mul -> result
	}
	result
}

pub fn min( a:any b:any -- result:any ) {
	// Minimum of two values (polymorphic - works with int or float)
	over over lt if {
		drop
	} else {
		nip
	}
}

pub fn max( a:any b:any -- result:any ) {
	// Maximum of two values (polymorphic - works with int or float)
	over over gt if {
		drop
	} else {
		nip
	}
}

// Additional utility functions

pub fn log( x:f64 base:f64 -- result:f64 ) {
	// log_base(x) = ln(x) / ln(base)
	swap ln swap ln div
}

pub fn clamp( x:f64 min_val:f64 max_val:f64 -- result:f64 ) {
	// Clamp x between min_val and max_val
	// Inline implementation to avoid function call scoping issues
	// Stack: x min_val max_val
	-> max_v
	-> min_v
	-> x_v

	// First: min(x, max_val)
	x_v max_v over over lt if { drop } else { nip } -> temp

	// Then: max(min_val, temp)
	min_v temp over over gt if { drop } else { nip }
}

pub fn within( x:any min_val:any max_val:any -- result:i64 ) {
	// Check if x is within [min_val, max_val] range (inclusive)
	// Returns 1 (true) or 0 (false)
	// Stack: x min_val max_val
	-> max_v
	-> min_v
	-> x_v

	// Check if x >= min_val AND x <= max_val
	x_v min_v gte
	x_v max_v lte
	and
}

pub fn lerp( a:f64 b:f64 t:f64 -- result:f64 ) {
	// Linear interpolation: a + (b - a) * t
	// Stack: a b t
	rot rot       // Stack: t a b
	over          // Stack: t a b a
	sub           // Stack: t a (b-a)
	rot           // Stack: a (b-a) t
	mul           // Stack: a ((b-a)*t)
	add           // Stack: (a+(b-a)*t)
}

pub fn deg_to_rad( degrees:f64 -- radians:f64 ) {
	// radians = degrees * pi / 180
	3.141592653589793 180 div mul
}

pub fn rad_to_deg( radians:f64 -- degrees:f64 ) {
	// degrees = radians * 180 / pi
	180 mul 3.141592653589793 div
}
