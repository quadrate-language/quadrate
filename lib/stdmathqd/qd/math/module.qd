// Mathematical constants
const Pi = 3.141592653589793
const E = 2.718281828459045
const Tau = 6.283185307179586

// Import native math functions from libstdmathqd
import "libstdmathqd_static.a" as "math" {
	// Trigonometric functions
	fn sin(x:f -- result:f)
	fn cos(x:f -- result:f)
	fn tan(x:f -- result:f)
	fn asin(x:f -- result:f)
	fn acos(x:f -- result:f)
	fn atan(x:f -- result:f)

	// Power and root functions
	fn sqrt(x:f -- result:f)
	fn sq(x:f -- result:f)
	fn cb(x:f -- result:f)
	fn cbrt(x:f -- result:f)
	fn pow(base:f exp:f -- result:f)

	// Logarithmic functions
	fn ln(x:f -- result:f)
	fn log10(x:f -- result:f)

	// Rounding functions
	fn ceil(x:f -- result:f)
	fn floor(x:f -- result:f)
	fn round(x:f -- result:f)

	// Utility functions
	fn abs(x:f -- result:f)
	fn min(a:f b:f -- result:f)
	fn max(a:f b:f -- result:f)
	fn fac(n:i -- result:i)
	fn inv(x:f -- result:f)
}

// Additional utility functions

fn log(x:f base:f -- result:f) {
	// log_base(x) = ln(x) / ln(base)
	swap ln swap ln div
}

fn clamp(x:f min_val:f max_val:f -- result:f) {
	// Clamp x between min_val and max_val
	// We want: max(min_val, min(x, max_val))
	// Stack: x min_val max_val
	swap          // Stack: x max_val min_val
	rot           // Stack: max_val min_val x
	rot           // Stack: min_val x max_val
	math::min     // Stack: min_val min(x, max_val)
	math::max     // Stack: max(min_val, min(x, max_val))
}

fn lerp(a:f b:f t:f -- result:f) {
	// Linear interpolation: a + (b - a) * t
	// Stack: a b t
	rot rot       // Stack: t a b
	over          // Stack: t a b a
	sub           // Stack: t a (b-a)
	rot           // Stack: a (b-a) t
	mul           // Stack: a ((b-a)*t)
	add           // Stack: (a+(b-a)*t)
}

fn deg_to_rad(degrees:f -- radians:f) {
	// radians = degrees * pi / 180
	3.141592653589793 180 div mul
}

fn rad_to_deg(radians:f -- degrees:f) {
	// degrees = radians * 180 / pi
	180 mul 3.141592653589793 div
}
