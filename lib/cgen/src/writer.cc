#include <cgen/writer.h>
#include <fstream>
#include <qc/ast.h>
#include <qc/ast_node.h>
#include <qc/ast_node_constant.h>
#include <qc/ast_node_function.h>
#include <qc/ast_node_identifier.h>
#include <qc/ast_node_literal.h>
#include <qc/ast_node_scoped.h>
#include <qc/ast_node_use.h>
#include <sstream>

namespace Qd {
	static int varCounter = 0;

	void Writer::write(IAstNode* root, const char* packageName, const char* filename) const {
		if (root == nullptr || packageName == nullptr || filename == nullptr) {
			return;
		}

		std::stringstream ss;

		Writer::writeHeader(ss);

		// Traverse the AST and generate code
		traverse(root, packageName, ss);

		Writer::writeFooter(ss);

		// Write to file
		std::ofstream file(filename);
		file << ss.str();
		file.close();
	}

	void Writer::writeMain(const char* filename) const {
		std::ofstream file(filename);
		file << "// This file is automatically generated by the Quadrate compiler.\n";
		file << "// Do not edit manually.\n\n";
		file << "#include <quadrate/runtime/runtime.h>\n\n";
		file << "extern qd_exec_result main_main(qd_context* ctx);\n\n";
		file << "int main(void) {\n";
		file << "    qd_context ctx;\n";
		file << "    qd_stack_init(&ctx.st, 1024);\n";
		file << "    main_main(&ctx);\n";
		file << "    qd_stack_destroy(ctx.st);\n";
		file << "    return 0;\n";
		file << "}\n";
		file.close();
	}

	void Writer::writeHeader(std::stringstream& out) const {
		out << "// This file is automatically generated by the Quadrate compiler.\n";
		out << "// Do not edit manually.\n\n";
		out << "#include <quadrate/runtime/runtime.h>\n\n";
	}

	void Writer::traverse(IAstNode* node, const char* packageName, std::stringstream& out, int indent) const {
		if (node == nullptr) {
			return;
		}

		// Helper to generate indentation string
		auto makeIndent = [](int level) { return std::string(static_cast<size_t>(level * 4), ' '); };

		// Process current node based on its type
		switch (node->type()) {
		case IAstNode::Type::Unknown:
			// Unknown node type, skip
			break;
		case IAstNode::Type::Program:
			out << "// Program\n";
			break;
		case IAstNode::Type::Block:
			out << makeIndent(indent) << "{\n";
			break;
		case IAstNode::Type::FunctionDeclaration: {
			AstNodeFunctionDeclaration* funcDecl = static_cast<AstNodeFunctionDeclaration*>(node);
			out << "\n"
				<< makeIndent(indent) << "qd_exec_result " << packageName << "_" << funcDecl->name()
				<< "(qd_context* ctx) {\n";
			out << makeIndent(indent + 1) << "QD_REQUIRE_STACK(ctx, " << funcDecl->inputParameters().size() << ");\n\n";
			traverse(funcDecl->body(), packageName, out, indent + 1);
			out << "\n"
				<< makeIndent(indent) << "qd_lbl_done:;\n"
				<< makeIndent(indent + 1) << "QD_REQUIRE_STACK(ctx, " << funcDecl->outputParameters().size() << ");\n"
				<< makeIndent(indent + 1) << "return (qd_exec_result){0};\n";
			out << makeIndent(indent) << "}\n";
			return; // Don't traverse children again
		}
		case IAstNode::Type::VariableDeclaration:
			// TODO: Handle variable declaration
			break;
		case IAstNode::Type::ExpressionStatement:
			// TODO: Handle expression statement
			break;
		case IAstNode::Type::IfStatement: {
			int64_t currentVar = varCounter++;
			std::string var = "qd_var_" + std::to_string(currentVar);
			out << makeIndent(indent) << "int64_t " << var << " = qd_stack_pop_i(ctx);\n";
			out << makeIndent(indent) << "if (" << var << " != 0) {\n";
			if (node->childCount() > 0) {
				traverse(node->child(0), packageName, out, indent + 1); // Then block
			}
			out << makeIndent(indent) << "}\n";
			break;
		}
		case IAstNode::Type::ForStatement:
			// TODO: Handle for statement
			break;
		case IAstNode::Type::SwitchStatement:
			// TODO: Handle switch statement
			break;
		case IAstNode::Type::CaseStatement:
			// TODO: Handle case statement
			break;
		case IAstNode::Type::ReturnStatement:
			out << makeIndent(indent) << "goto qd_lbl_done;\n";
			break;
		case IAstNode::Type::BreakStatement:
			out << makeIndent(indent) << "break;\n";
			break;
		case IAstNode::Type::ContinueStatement:
			out << makeIndent(indent) << "continue;\n";
			break;
		case IAstNode::Type::DeferStatement:
			// TODO: Handle defer statement
			break;
		case IAstNode::Type::BinaryExpression:
			// TODO: Handle binary expression
			break;
		case IAstNode::Type::UnaryExpression:
			// TODO: Handle unary expression
			break;
		case IAstNode::Type::Literal: {
			AstNodeLiteral* literal = static_cast<AstNodeLiteral*>(node);
			switch (literal->literalType()) {
			case AstNodeLiteral::LiteralType::Integer:
				out << makeIndent(indent) << "qd_push_i(ctx, (int64_t)" << literal->value() << ");\n";
				break;
			case AstNodeLiteral::LiteralType::Float:
				out << makeIndent(indent) << "qd_push_f(ctx, (double)" << literal->value() << ");\n";
				break;
			case AstNodeLiteral::LiteralType::String:
				out << makeIndent(indent) << "qd_push_s(ctx, " << literal->value() << ");\n";
				break;
			}
			break;
		}
		case IAstNode::Type::Identifier: {
			AstNodeIdentifier* ident = static_cast<AstNodeIdentifier*>(node);
			out << makeIndent(indent) << "qd_" << ident->name() << "(ctx);\n";
			break;
		}
		case IAstNode::Type::ScopedIdentifier: {
			AstNodeScopedIdentifier* scopedIdent = static_cast<AstNodeScopedIdentifier*>(node);
			out << makeIndent(indent) << "qd_" << scopedIdent->scope() << "_" << scopedIdent->name() << "(ctx);\n";
			break;
		}
		case IAstNode::Type::UseStatement: {
			// TODO: Handle use statement
			AstNodeUse* use = static_cast<AstNodeUse*>(node);
			out << makeIndent(0) << "#include <something/" << use->module() << ".h>\n";
			break;
		}
		case IAstNode::Type::ConstantDeclaration: {
			AstNodeConstant* constDecl = static_cast<AstNodeConstant*>(node);
			out << makeIndent(indent) << "#define " << packageName << "_" << constDecl->name() << " "
				<< constDecl->value() << "\n";
			break;
		}
		case IAstNode::Type::Label:
			// TODO: Handle label
			break;
		}

		// Determine the indentation level for children
		int childIndent = indent;
		if (node->type() == IAstNode::Type::Block) {
			childIndent = indent + 1;
		}

		// Recursively traverse all children
		for (size_t i = 0; i < node->childCount(); i++) {
			traverse(node->child(i), packageName, out, childIndent);
		}

		// Post-process node if needed
		if (node->type() == IAstNode::Type::Block) {
			out << makeIndent(indent) << "}\n";
		}
	}

	void Writer::writeFooter(std::stringstream& out) const {
		out << "\n// End of generated code\n";
	}
}
