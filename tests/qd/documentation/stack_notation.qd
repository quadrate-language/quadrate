// This test demonstrates Quadrate's stack notation in function declarations
// Format: fn name(inputs -- outputs)
// Where inputs and outputs have name:type annotations

use math
use bits

// Basic arithmetic with stack notation
fn add_numbers(a:i64 b:i64 -- result:i64) {
	// a and b are consumed from stack, result is produced
	+
}

fn multiply_then_add(a:i64 b:i64 c:i64 -- result:i64) {
	// Stack is [a, b, c] with c on top
	// Computes (b * c) + a
	* +
}

// Functions with float parameters
fn multiply_floats(a:f64 b:f64 -- result:f64) {
	*
}

fn divide_floats(a:f64 b:f64 -- result:f64) {
	/
}

// Stack manipulation operations
fn swap_values(a:i64 b:i64 -- b:i64 a:i64) {
	swap
}

// Functions demonstrating stack effects
fn square_and_double(x:i64 -- x2:i64 x_times_2:i64) {
	// Returns x*x and x*2
	dup
	dup mul swap
	2 *
}

// Min/max operations with stack notation
fn triple_min(a:i64 b:i64 c:i64 -- min:i64) {
	math::min
	math::min
}

fn triple_max(a:i64 b:i64 c:i64 -- max:i64) {
	math::max
	math::max
}

// Logical operations
fn bitwise_and_or(a:i64 b:i64 c:i64 -- result:i64) {
	bits::and
	bits::or
}

// Functions demonstrating drop
fn keep_first(a:i64 b:i64 -- a:i64) {
	drop
}

fn keep_first_of_four(a:i64 b:i64 c:i64 d:i64 -- a:i64) {
	drop2
	drop
}

// Rotation example
fn rotate_three(a:i64 b:i64 c:i64 -- b:i64 c:i64 a:i64) {
	rot
}

// Mixed types
fn int_to_float_calc(a:i64 b:f64 -- result:f64) {
	// Integer is automatically promoted to float
	+
}

// Demonstrate stack notation with no parameters
fn get_answer( -- answer:i64) {
	42
}

// Consume but produce nothing
fn consume_two(a:i64 b:i64 -- ) {
	drop
	drop
}

fn main( -- ) {
	// Test basic arithmetic
	5 3 add_numbers . nl
	// Should print nl 8
	2 3 4 multiply_then_add . nl
	// Should print nl 14 ((3*4)+2)
	// Test float operations
	3.5 2.0 multiply_floats . nl
	// Should print nl 7.000000
	10.0 4.0 divide_floats . nl
	// Should print nl 2.500000
	// Test stack manipulation
	10 20 swap_values . nl . nl
	// Should print nl 10, 20
	// Test multiple outputs
	5 square_and_double . nl . nl
	// Should print nl 10, 25
	// Test triple min/max
	5 3 8 triple_min . nl
	// Should print nl 3
	5 3 8 triple_max . nl
	// Should print nl 8
	// Test logical operations
	12 10 3 bitwise_and_or . nl
	// Should print nl 14 ((10 & 3) | 12 = 2 | 12)
	// Test drop operations
	100 200 keep_first . nl
	// Should print nl 100
	1 2 3 4 keep_first_of_four . nl
	// Should print nl 1
	// Test rotation
	1 2 3 rotate_three . nl . nl . nl
	// Should print nl 1, 3, 2
	// Test mixed types
	5 3.5 int_to_float_calc . nl
	// Should print nl 8.500000
	// Test function with no inputs
	get_answer . nl
	// Should print nl 42
	// Test function with no outputs
	99 88 consume_two
	// Consumes but prints nothing
	// Test negation with clear stack effect
	42 neg . nl
	// Should print nl -42
	// Test modulo
	17 5 mod . nl
	// Should print nl 2
	// Demonstrate inline stack notation as comments
	// (a b -- min max) Pattern: get both min and max
	// We can't use dup2 on parameters yet, so we use explicit values
	7 13 dup2
	math::min
	rot
	rot
	math::max . nl . nl
	// Should print nl 13, 7
}
